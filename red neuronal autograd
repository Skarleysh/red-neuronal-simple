importar autograd.numpy como np
 desde autograd import grad, elementwise_grad
 importar autograd.numpy.random como npr
 desde autograd.misc.optimizers importar adam
 
 def  init_random_params (scale, layer_sizes, rs = npr.RandomState (0)):
 "" "Construye una lista de (pesos, sesgos) tuplas, una para cada capa." "" return [(rs.randn (insize, oversize) * escala,    # matriz de peso rs.randn (tamaño grande) * escala)            # vector de sesgo para tamaño interior, tamaño grande en zip (layer_sizes [: - 1], layer_sizes [1:])]    
    
    def  swish (x):
 "ver https://arxiv.org/pdf/1710.05941.pdf" return x / (1.0 + np.exp (-x))
 
 def  f (parámetros, entradas):
 "Funciones de red neuronal" para W, b en parámetros:
 salidas = np.dot (entradas, W) + b
 entradas = swish (salidas)
     devolver salidas
     
     # Aquí está nuestra suposición inicial de params: 
params = init_random_params (0.1, layer_sizes = [1, 8, 1])

# Derivadas 
fp = elementwise_grad (f, 1)
 fpp = elementwise_grad (fp, 1)
 fppp = elementwise_grad (fpp, 1)

eta = np.linspace (0, 6) .reshape ((- 1, 1))

# Esta es la función que buscamos para minimizar 
def  objetivo (params, paso):
 # Todos estos deben ser cero en la solución # f '' '+ 0.5 f' 'f = 0 zeq = fppp (params, eta) + 0.5 * f (params, eta) * fpp (params, eta) 
 bc0 = f (params, 0.0)   # igual a cero en la solución bc1 = fp (params, 0.0)   # igual a cero en la solución bc2 = fp (params, 6.0) - 1.0 # este es el que está en "infinito" return np.mean (zeq ** 2) + bc0 ** 2 + bc1 ** 2 + bc2 ** 2    
      
   def  callback (params, step, g):
 if step% 1000 == 0:
 print ( "Iteración {0: 3d} objetivo {1}" . formato (paso,
 objetivo (params, paso)))
 
 params = adam (grad (objetivo), params,
 step_size = 0.001, num_iters = 10000, callback = callback)
 print ( 'f (0) = {}' . format (f (params, 0.0)))
 print ( 'fp (0) = {}' . format (fp (params, 0.0)))
 print ( 'fp (6 ) = {} ' . format (fp (params, 6.0)))
 print ( ' fpp (0) = {} ' . format (fpp (params, 0.0)))

importar matplotlib.pyplot como plt
plt.plot (eta, f (params, eta))
plt.xlabel ( '$ \ eta $' )
plt.ylabel ( '$ f (\ eta) $' )
plt.xlim ([0, 6])
plt.ylim ([0, 4.5])
plt.savefig ( 'nn-blasius.png' )
